using System.Collections.Generic;
using UnityEngine;

namespace BzKovSoft.ObjectSlicer
{
	/// <summary>
	/// The object represents one new GameObject that will be generated by the end of the process
	/// </summary>
	public class OneObjectItem
	{
		public int groupNumber;
		public GameObject newObject;
		public bool side;
		public List<OneObjectItemMesh> meshes;
	}

	/// <summary>
	/// The object represents one mesh from the result GameObject
	/// </summary>
	public class OneObjectItemMesh
	{
		public bool Side { get; set; }
		public SliceType SliceType { get; set; }
		public Renderer MeshRenderer { get; set; }
		public BzMeshDataDissector MeshDissector { get; set; }
		public BzMeshData MeshData { get; set; }
		public BzMeshItemData Mesh { get; set; }
		public float Volume { get; set; }
		/// <summary>
		/// Center of mass. World position.
		/// </summary>
		public Vector3 CenterOfMass { get; set; }
		public Vector3 CenterOfPoints { get; set; }

		public void AddMesh(OneObjectItemMesh another)
		{
			Debug.Assert(SliceType == SliceType.Slice, "Wrong SliceType");
			Debug.Assert(Side == another.Side, "Wrong Side");
			Debug.Assert(MeshRenderer == another.MeshRenderer, "Wrong MeshRenderer");
			Debug.Assert(MeshDissector == another.MeshDissector, "Wrong MeshDissector");
			Debug.Assert(MeshData == another.MeshData, "Wrong MeshData");

			Volume += another.Volume;
			float volumeRate = another.Volume / (Volume + another.Volume);
			float pointsRate = another.Mesh.triangles.Count / (Mesh.triangles.Count + another.Mesh.triangles.Count);
			CenterOfMass += CenterOfMass * (1 - volumeRate) + another.CenterOfMass * volumeRate;
			CenterOfPoints += CenterOfPoints * (1 - pointsRate) + another.CenterOfPoints * pointsRate;

			Mesh.triangles.AddRange(another.Mesh.triangles);
		}
	}

	/// <summary>
	/// Intermidiate mesh unit
	/// </summary>
	public class BzMeshItemData
	{
		public bool side;
		public List<BzTriangle> triangles;
	}
}